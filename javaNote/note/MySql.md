[TOC]



### 数据库的三个范式

+ 第一范式：每个字段都是原子性的，不能在继续分解。
+ 第二范式：表必须有主键，非主属性必须完全依赖而不能部分依赖主键
+ 第三范式：非主属性必须直接依赖到主键，不能间接的依赖主键
### 数据库分库分表
为什么分库分表：
1. 业务拆分，复杂系统变简单
2. 数据隔离，将核心业务和非核心业务区分开

分布式ID生成服务：
1.使用Twitter的snowflake,生成一个（完全无序，趋势递增，单调递增）具体业务具体分析

join查询的问题
1. 将join的几个表都改成单表查询，使用代码进行拼装。
2. 提前将join结果写好写到一个表中
3. 使用搜索引擎，将数据库数据导入到ES中进行查询

### B+树（逻辑结构）
1. 叶子节点上所有索引值从小到大顺序排序，双向链表，每一个key执行一条记录
2. 所有的非叶子节点的数据都是冗余的，每个节点存储的叶子节点的最小值，同层也是双显链表

### 基于B+树的索引可以实现
1. 范围查询：查询范围最大值和最小值，然后顺序遍历
2. 排序：索引天然支持排序，
3. 分页：大偏移量的分页，先查出将offset=1000的位置换算成某个userId

### B+树（物理结构）
1. 每个page的大小16kb，

### 思考
1. 为什么按照主键的递增顺序插入记录？为了避免page split问题

### 非主键索引
1. 结构与主键索引相类似，但是在叶子节点上存储的不是记录的指针而是主键值。
先通过非主键索引找到主键值，在通过主键索引找到记录。所以非主键索引查询两个B+树。

### 事务与锁

1. 事务：一个代码块全执行或全不执行

2. 事务之间的并发关系导致事务的隔离级别

   | 脏读     | 事务a读取一条记录，做修改在提交之前，事务b回滚了他对这条记录的修改，导致a读的是一条脏数据 |      |
   | -------- | ------------------------------------------------------------ | ---- |
   | 不可重读 | 一个事务两次读取同一条记录，结果不用，因为另一个事务正对此条记录进行修改 |      |
   | 幻读     | 同一个事务中，两条select结果不同，因为另外一个表在进行INSERT/Update操作 |      |
   | 丢失更新 | 丢失更新，两个事务同时修改一条记录，事务a覆盖了事务b的修改   |      |

3. 事务的隔离级别

   + 原子性：事务全不执行，或全部执行，执行失败要回滚
   + 一致性：保证了一个事务多次操作的数据中间状态对其他事务不可见，过度状态对于事务开始和结束的状态是不一致的不合理的。
   + 隔离性：事务之间不能互相影响
   + 持久性：提交的事务对数据的修改是永久性

4. 为了解决事务的隔离级别，InnoDB提供乐四种事务隔离级别

   | RU（读未提交）  | 可以读取到未提交的事务修改的数据                             | 什么都没解决                   |
   | --------------- | ------------------------------------------------------------ | ------------------------------ |
   | RC （已提交读） | 只能读取到已提交的事务的修改                                 | 解决了脏读问题                 |
   | RR （可重复读） | 在同一分事务中读取的相同一条数据不会受其他数据影响，数量也不会受其他事务影响 | 解决了脏读、不可重读、丢失更新 |
   | 串行化          | 解决所有问题                                                 | 完全解决所有问题               |

#### 悲观锁和乐观锁

1. 默认的隔离级别没有解决丢失更新的问题，如何解决丢失更新的问题

   + 利用单条语句的原子性（就是能写成一条语句的sql不写成查询出在再修改的形式）

   + 悲观锁：读之前就对该记录进行上锁，其他事务无法读取当前记录

     ```sql
     select xxx for update
     --1、在事务提交之前出现问题容易出现死锁，2、不适合高并发的场景，当前事务之外的事务都会被阻塞
     ```

   + 乐观锁：读不加锁，写的时候会判断记录是不是被修改（相当于数据库层面的CAS）。给表加一个version

     在一个update语句中实现version的修改，version 的比较，值得修改操作。属于原子性操作，所以可以解决丢失更新问题。

     


### 事务的实现原理

##### Redo Log

    1. 在事务修改后会使用write-ahead logging 算法，先写redo log 记录对数据库的修改结果，调用后台线程将该结果存储到物理引擎，如果出现断电等异常问题时，mysql可以使用redo 日志将数据恢复到断电之前的状态，维护事务的持久性。
       2. redo log 记录了提交的和未提交的所有事务的修改，而且一个事务在redolog中可能是不连续的，

```sql
--redolog的异步的刷盘策略：默认每秒刷一次盘，每提交一个事务刷一次盘，不刷盘按照自己的设置决定刷盘频率
--redo log是一个固定大小的文件，循环使用，因为一旦数据刷到磁盘上，redo log就没存在的必要了
```

3. 在redolog中 lsn按照时间顺序上从小到大，记录从进数据库安装开始到当前总的写入得字节数。LSN不从0开始，从8192开始因为innodb维护了一个LOG_START_LSN变量。事务有大有小，所以日志记录是变长的。

4. ![](.\redolog.png)

5. 日志的存储格式

   - 类似binlog的statement格式，记录原始sql 增改删，属于逻辑计法

   - 类似binlog的raw格式，记录每张表的每条记录的修改前的值和修改后的值，属于逻辑计法

   - 记录每个页的字节数据，有哪些部分被修改，如果有多个地方被修改就会有多条物理日志。物理记法

     ```(pageId,offset,len,修改前的值，修改后的值)```

   - redolog使用的是物理加逻辑（physiological logging），先以page记录日志，然后在page内使用逻辑记法（记录page的哪一行被修改了）。单纯的逻辑日志不好恢复，单纯物理物理日志又很大，所以mysql使用的是physiological logging

6. 事务、lsn、logblock的关系

   - 一个事务在logblock上的可能是连续的也可能是不连续的，中间有其他事务的日志。

   - 每个事务产生的lsn在redo log中是一链表的形式连接的

   - 每个事务会有一个单调递增的唯一的ID，由InnoDB分配

     

7. IO写入得原子性

   - 实现事务的原子性，需要考虑计算机是不是支持io的原子性，可以使用checkSum解决在512LogBlock中写入时出现宕机问题（操作系统底层不支持512原子性写的操作，如果支持不需要考虑这个问题），checksum可以判断一个blocklog是否完整，如果不完整就丢弃这个块。
   - Double Write redolog有写入得原子性问题，page的写入也肯定有问题，
   - 两种解决办法： 1. 让计算机支持16kb的原子性写入，2.将page写到一个临时磁盘，写入成功在拷贝到目标位置。
   - redo log的写入方式一块一块的写入。log文件为一组文件，可以理解为一个大文件。
   
8. redoLog 恢复算法：

   - 第一步：在系统中维护两个表，一活跃事务表：当前所有未提交事务的集合 二脏页表：所有未刷磁盘page的集合。每隔一段时间会根据两个表生成checkpoint存到redolog中，恢复时可通过checkpoint判断有哪些事务为提交，那些page的修改未刷盘
   - 第二部：进行redo ，根据page内记录的pageLSN(最后一次修改他的日志的LSN)，redolog的SLN只有>=pageSLN时才会进行修改，修改完成后，所有的脏页都写入到了磁盘，提交的未提交的事务也都写入了磁盘。下一步将是对事务进行回滚。
   - 第三部：进行undo。redolog的每条日志有prevLSN，沿着未提交的事务逆向遍历可以找到为提交事务的第一条记录。根据每个事务的日志生成一个逆向的sql语句执行。
   - 不会出现回滚嵌套问题，因为回滚申城的日志记录了undonxtLSN记录了下一个需要回滚的事务。有此标记的事务不再惊醒会滚。

9. redolog总结

   - 一个事务对应多条redolog，事物的redolog是不连续存储的
   - redolog不保证食物的原子性。而保证了持久性。无论是提交的和未提交的事务都会进入到redolog。
   - 回滚通过checkpoint记录的“”活跃事务表+脏页表“”来实现
   - 无论是未提交的还是提交的事务，对应的page的数据都可能被刷到磁盘中。通过事务回滚未提交的事务。
   - 事务不存在物理回滚。的所有的回滚都是转化为了commit



### 事务的实现原理undo log

#### 事务回滚的场景

1. 人为回滚，事务执行发生异常，客户端调用回滚
2. 宕机回滚，事务执行到一半数据库宕机，重启，需要回滚
3. 人为+宕机。客户端调用回滚，数据库开始回滚，回滚到一般出现宕机，继续回滚
4. 宕机回滚+宕机回滚，宕机回滚中又出现宕机

####  Undo Log （MVCC）

1. 多线程并发的读写问题的三种策略
   - 互斥锁：任何操作都是互斥的
   - 读写锁：除读和读外的任何操作都是互斥的
   - CopyOnWrite：将数据拷贝一分，等写完之后，再把数据对象的指针，一次性赋值回去。读的时候读取原始数据，可以实现读和读的并发，读和写的并发，理论上写和写的并发
2. MVCC就是多版本并发控制，innodb使用了copyOnWrite思想，每个事务修改记录之前，都会把该条记录拷贝出来，拷贝出来的备份就存到undo log内，事务有唯一编号，每次修改就是一个版本，这种方法维护了事务的隔离性，满足前三个隔离级别。



### 各种锁

1. 按照锁的粒度来分：可分为锁表、锁行、锁一个范围
2. 按照锁的模式来份：可分为共享、排他、意向
3. 两个维度叉乘会形成各种锁
4. 共享锁、排他锁、意向锁、记录锁、间隙锁、临建锁、插入意向锁、自增锁

### 具体锁的用途

1. 意向锁，表级别的锁。事务A在加一个行排他锁，事务B想加一个表排他锁，事务B需要进行全行扫表判断哪一行家了排他锁，再确定，是不是能获得表排他锁。效率低下的问题产生了意向锁。表的加一个意向排他锁，代表了接下来要加一个行排他锁，其他事物想加表排他锁的时候就不需要进行遍历了。
2. 自增锁，表级别的锁。 

#### Hash索引

+ 基于hash表+链表的数据结构，只有精确匹配索引所有列的时候查询才有效果，hash索引对每一行的所有列进计算一个哈希码。
+ 哈希索引值包含哈希值和行指针，二部存储字段值，不能使用索引中的值来避免读取行
+ 哈希表的数据结构，无法排序
+ 不支持部分列的单独索引查询。因为他是全列进行哈希的
+ 不支持范围查询
+ 查询数据非常快，除非有很多哈希冲突
+ InnoDB不支持用户创建hash索引，他有自适应哈希索引你，如果某些索引值被使用的非常频繁，她会在B-Tree基础上建立一个哈希索引

#### 空间数据索引

#### 全文索引

#### 索引的有点

+ 减少服务器需要扫描的数据量
+ 把那帮助服务器避免排序和临时表
+ 将随机I/O变成顺序I/O

### 索引失效

+ 索引字段必须是独立的列，不允许加入任何聚合函数和表达式

  ```sql
  EXPLAIN SELECT * FROM usermultinfopar WHERE userid + 1 = 123
  ```

  

+ 前缀索引和索引的选择性

  + 索引合并，UNION 、INTERSECTION、组合前两种情况的联合及相交。

+ 选择合适的索引顺序

#### 

## 锁

### 1.锁的分类

+ 共享锁

+ 排他锁

> 只有共享锁和共享锁之间可以兼容，不兼容的锁，想要给表加锁的事务会进入等待状态。

### 2.意向锁

> 允许在行级和表级上的锁同时存在，支持不同粒度上进行加锁操作

### 3.一致性非锁定读MVCC

> 一个事务读取一个正在update和delete的行时，不会等待行上锁的释放，它可以去读取行的一个快照数据。
>
> 在RC（读已提交）事务隔离级别下，非一致读总是读取最新的一个快照
>
> 在RR（可重复读）事务隔离级别情况下，非一致读总是读取事务开始的快照

### 4.一致性锁定读

> SELECT语句支持两种一致性锁定读，事务提交的时候锁被释放

```sql
select *** for update
select **** lock in share mode
```

### 5锁的三种算法

+ Record Lock：单个行记录上的锁
+ Gap Lock：锁定一个范围，但是不包含记录本身
+ Next-Key Lock：锁定记录范围，并且包含记录本身，
  + 在已经锁定的（10，11] (11,13] 上插入新的记录，会将范围分裂成（10，11]、（11,12]，（12，13]
  + 如果存在唯一索引则会将Next-Lock进行优化降级为Record Lock
  + 另外InnoDB还会对



### 6.解决Phantom Problem（幻读）问题

+ 在RR隔离级别下使用的是Next-Key Locking来解决的幻读问题。上锁锁住的是一个范围，而不是的那个值
+ 幻读：同一个事务下，两次SQL执行，第二词有可能返回之前不存在的行

### 7.锁问题

#### 7.1脏读

+ 脏读：读取到另一个事务未提交的修改

#### 7.2不可重读

+ 一个事务中读取到了另外的事务已经修改的提交。在RR级别下，MYSQL使用Next-Key Locking来解决不可重读问题

#### 7.3丢失更新

+ 同时修改同一事物的数据，后面的修改会覆盖掉前面的修改。将事务的隔离界别修改成串行化

### 8.死锁

+ 两个事务以上，因互相争夺所资源造成的互相等待的现象。
+ 解决死锁问题：
  + 超时，等待超时进行回滚
  + 等待图：维护两张表（锁的信息链表，事物的等待链表）从这两张表构造出一张图，若途中出现回路，则代表死锁。

### 9.锁升级

+ 单条sql在一个对象上持有锁的数量炒股了阈值，默认5000
+ 所资源占用的内存超过了激活内存的40%

## 事务

### 1.事物的性质

+ 原子性
+ 一致性
+ 隔离性
+ 持久性

### 2.事务的分类

+ 扁平事务：出现问题全部回滚
+ 带有保存点的扁平事务：带有保存点，出现问题不比全部回滚，可以回滚到保存点
+ 链事务：可以恢复到最近一个保存点，
+ 嵌套事务
+ 分布式事务

### 3.事务的实现

+ redo：
  + 包括两部分，内存中的重做日志缓冲区（redo log buffer）、重做日志文件，
  + 一个事务commit只有等到redolog写入完成后才算完成，这里的日志包括redo和undo，前者保留事务的持久性，后者帮助回滚事务和MVCC，
  + redo log是顺序的，undo log是随机的。
+ 什么时候会写redo
  + 事务提交
  + log buffer 一般内存空间被使用
  + check point 时
+ undo：用来做回滚和MVCC的
+ binlog：用来主从之间做复制的

## 索引

### 1.InnoDb支持的索引

+ B+树：只能找到数据所在页，将页数据读到内存中，然后再进行查找
+ 全文
+ 哈希：引擎根据表的使用情况，自动生成，不能认为指定

### 2.B+树

+ B+数的索引： 聚集索引和辅助索引



















## 面試

### 1.Mysql的架构

+ 连接层，完成类似链接处理授权验证的相关安全的方案
+ 服务层，完成大多数的和性服务功能，如SQL接口，缓存的查询，SQL分析和优化，部分内齿函数的执行
+ 引擎层，负责对数据进行存取
+ 存储层，将数据存储到文件系统上，完成与存储引擎的交互

### 2.InnoDB和MyISAM的区别

+ 前者支持事务，后者不支持
+ 前者是行锁，后者是标所
+ 前者批量插入速度相对于后者慢
+ 前者支持外键，后者不支持

### 3.InnoDB的RESTRICT、CASCADE、SET NULL 和 NO ACTION是什么意思

+ RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下，父表不能更新
+ CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录
+ SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 

### 4.如何使用explain查看sql

+ id：执行select语句或者操作表的顺序，id 不同id值越大，优先级越高，越先被执行。
+ select_type：select的类型，SIMPLE、UNION、SUBQUERY
+ table：表名
+ type：表示表的连接类型，性能由好到差的连接类型为( system  --->  const  ----->  eq_ref  ------>  ref  ------->  ref_or_null---->  index_merge  --->  index_subquery  ----->  range  ----->  index  ------> all )  
+ possible_keys：可能使用到的索引
+ key：实际使用的索引
+ key_len：索引字段的长度
+ rows：扫描的行数
+ extra：额外的说明
  + using  filesort  文件排序 效率低
  + using  temporary  用了临时表
  + using  index 使用了覆盖索引

### 5.如何定位慢sql

+ show profiles可以查看sql执行的耗时时间
+ show  profile可以查看一条sql的每个阶段的消耗时间
+ trace 跟踪sql查看优化器对sql进行的优化过程

### 6.避免索引失效

+ 最左前缀法则：一个包含多列的索引，要从左列的第一个开始不能并且不跳过索引中的列
  + 如果跳过了中间的，那么只有之前的会用到索引
+ 不要在索引列上进行运算操作， 索引将失效。
+ 字符串不加单引号，造成索引失效。（隐式的进行类型转换）
+ 使用select * 会造成回表，尽量使用覆盖索引
+ 用or链接的前列有索引后列无索引的情况下，索引失效
+ 模糊匹配只能使用'XX%' 或者使用覆盖索引来进行操作
+ is  NULL ， is NOT NULL  <font color='red'>有时</font>索引失效是因为优化器对查询进行了优化

### 7.大数据量得插入

+ 手动提交事务
+ 如果有索引列，将索引列进行排序

### 8.group by的优化

+ GROUP BY 实际上也同样会进行排序操作
+  则可以执行order by null 禁止排序

### 9.大偏移量的分页查询

+  将limit查询换成某个位置的查询
+ 在索引上完成分页排序，然后通过索引来关联出其他字段

### 10.无索引行锁升级为表锁

+ 如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。


### 11.主从复制的原理

+ Master 主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中。
+ 主库推送二进制日志文件 Binlog 中的日志事件到从库的中继日志 Relay Log 。
+ slave重做中继日志中的事件，将改变反映它自己的数据。

### 12.主从复制的优点

+ 主库出现问题，可以快速切换到从库提供服务。
+ 可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力
+ 可以在从库中执行备份，以避免备份期间影响主库的服务

