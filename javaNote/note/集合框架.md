# 集合框架

## 一、Collection接口

### 1.1 整体继承关系

![image-20220208194359863](../image/集合框架/image-20220208194359863.png)

### 1.2 LinkedList

双向链表，内部实现了一个Node类，构造方法支持，pre，next和element传参

```java
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;
        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

> **该类实现了Dqueue，该接口定义了双端链表，分别可以从头部和尾部进行插入和删除操作**

### 1.3 ArrayList

单纯使用Object数组实现，预先预留一定的数组空闲空间，空间不够进行扩容，扩容每次扩容到原来的1.5倍

### 1.4 CopyOnWriteArrayList

使用写时复制算法，底层实现还是Object[] array; 通过 ReentrantLock+ volite实现，读不加锁，写使用通一把锁，写时将数组copy一份，操作备份数组，写完成后替换原数组。

+ 优点：空间换时间，写不阻塞读
+ 缺点：写阻塞，只适合读多写少的场景，写时读无法获取最新的写数据

```java
public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
```



### 1.5 TreeSet

使用TreeMap的Key进行操作，value为object对象

```java
public TreeSet() {
    this(new TreeMap<E,Object>());
}

public boolean add(E e) {
    return m.put(e, PRESENT)==null;
}
```

### 1.6 HashSet

同TreeSet一样，使用HashMap的key进行操作，value为Object对象

```java
public HashSet() {
    map = new HashMap<>();
}

public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}

```

### 二、Map接口

> 整体继承关系

![image-20220208202030360](../image/集合框架/image-20220208202030360.png)

### 2.1 HashMap

#### 2.1.1 数据结构

> 数组+链表+红黑树

#### 2.1.2 初始化Object数组（获取一个2的n次幂）

+ 1.8 

```java
static final int tableSizeFor(int cap) {
    // 先进行减1，避免cap就是一个2的n次幂
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    // 通过移位运算后，n由00000000 00000000 00000000 00010001变成了
    // 00000000 00000000 00000000 00011111 这种，这个数只比目标数小1
  	// 如果最终结果不大于最大值，直接返回n+1即可
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

+ 1.7 调用Integer的higestOneBit方法，传入参数为  cap < 1 - 1 相当于乘以2减1

```java
public static int highestOneBit(int i) {
	// HD, Figure 3-1
	i |= (i >>  1);
	i |= (i >>  2);
	i |= (i >>  4);
	i |= (i >>  8);
	i |= (i >> 16);
	return i - (i >>> 1);
}
```

#### 2.1.3 hash()

```java
static final int hash(Object key) {
    int h;
    // 这里将高位和地位进行异或运算，为了表面数组长度比较小的时候，忽略高位对数组index计算的影响
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

#### 2.1.4 put()

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
       	// 这里对数组进行了初始化，调用空构造方法的时候，只是制定了加载因子，未进行初始化
        n = (tab = resize()).length;
    // 这里使用hash值与数组size-1进行与运算计算下标
    if ((p = tab[i = (n - 1) & hash]) == null)
        // 这个桶里面没有元素，直接创建一个node，放进去
        tab[i] = newNode(hash, key, value, null);
    else {
        // 已经有元素，代表出现了hash冲突
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            // 这里先比对hash值，在比对key值
            e = p;
        else if (p instanceof TreeNode)
            // 如果顶层节点是红黑树类型，则调用红黑树插入
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 不是红黑树，说明还是链表
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    // 如果下一个是null，则可以直接插入，因为首个元素在前面已经判断过了
                    p.next = newNode(hash, key, value, null);
                    // 当前循环走完binCount才会++，也就是说，只有原有的元素>=8的时候
                    // 或者插入新元素完后，链表长度>8才转化为红黑树
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                // 如果当前元素
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        // 这里如果是已经存在的key，需要将原来的值返回
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    // 维护size，如果大于
    if (++size > threshold)
        resize();
    // 这里是给linkedHashmap插入元素后进行的回调
    afterNodeInsertion(evict);
    return null;
}
```

#### 2.1.5 resize()

```java
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
    	// 之前未进行初始化过，在此处扩容
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 扩容两倍
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    // 老数组原来有值， 需要进行节点迁移
    if (oldTab != null) {
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            // 遍历所有的桶，如果当前桶不为空
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    // 当前桶只有一个节点
                	// 直接计算数组下标
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    // 如果当前桶是红黑树
                    // 
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    // 当前节点是链表，
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        // 这里使用hash值与cap进行与运算
                        // 将此链表上的数据分成两份，
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) {
                        loTail.next = null;
                        // 高位为0的直接放到对应的index下面
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        // 高位为1的放到index+cap下面
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```



### 2.2 HashTable

>  使用Synchronized实现线程安全

```
// 计算数组下标使用取模运算
int index = (hash & 0x7FFFFFFF) % tab.length;
// 默认使用11作为初始大小
public Hashtable() {
        this(11, 0.75f);
}
```

### 2.3 TreeMap



### 2.4 ConcurrentHashMap
