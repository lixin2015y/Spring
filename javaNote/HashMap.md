# HashMap1.7

#### 使用大于capicaty的2的次方数进行初始化（用于计算数组下标）

+ 调用Integer类的higestOneBit()
  + 2的次方数就是1000000000000类似这种1后面全0的（只有一个1剩下全是零）
  + 将一个十进制数转化为2进制数
  + 对此二进制数右移1、2、4、8、16 分别进行或运算（有1出1）从左到右第一个非0 会将后面的数全置1，得到一个 类似0111111的32位二进制数
  + 用0000011111数减去此数无符号数右移1位，既可以得到一个类似00000100000000的二进制数，
+ 调用higestOneBit()方法传递的参数是 capicaty<1 -1（相当于乘2减1） 保证找到的一个是大于当前capicaty的最小的二进制数，减1 的目的是防止本身的capicaty就是一个2的次方数、

1001 0010

0100 1001

#### 计算数组下标

+ hash值和数组长度-1进行与运算。
+ 只用到了hash值得后面n位将前面的都置0 ，得到一个位于0到size-1的值
+ 只要一个2的次方的数才能进行-1变成 01111111直接得到对应hash值得数组下标

+ 如果数组的长度很少，hashcode的高位的变化无法影响计算index，容易发生冲突
  + 解决办法，将高位和低位进行异或，高位和低位的变化都会影响结果，这一操作在hash方法中进行,



#### 扩容

+ 大于阈值 （数组长度乘加载因子）并且当前要插入的地方不是空的
+ 扩容
  + 数组扩容到原来的两倍
  + 遍历老数组的所有不为空的元素
  + 循环一个桶的链表，一个个copy到新的table，使用头插入法，所以原来的链表的顺序会逆转，
  + 第二个县城copy到一定数量的元素后，由于第一个线程的操作，已经将链表翻转，所有第二个线程迭代就会造成死循环
  + 