[TOC]



# 内存模型

## 线程独占

### 虚拟机栈

#### 栈帧

​	栈帧的大小在编译期既可以知道，64位的log和double类型占用两个局部变量空间，其余的占一个。

+ 局部变量表： 基本类型、对象的引用。大小在在编译期间就完成分配。
+ 操作数栈
+ 动态链接
+ 方法出口

##### 对象引用的两种方式

+ 直接引用： 栈帧中的Reference直接指向堆中的实例、实例中有对象类型数据的引用、相对于句柄引用来说节省一次指针定位的开销

+ 句柄：Reference指向句柄池，句柄池中有实例的引用和对象类型的引用。在对象移动时（垃圾回收）不需要修改Reference

### 程序计数器

当前线程执行的字节码的行号，可以控制循环，分支，异常处理，和保证线程切换回到正确位置

### 本地方法栈

同虚拟机栈

## 线程共享

### 堆

虚拟机启动时创建、用于分配对象实例

### 方法区

+ 存放被虚拟机加载的类信息，常量、静态变量，对此区域的回收主要是想对常量池的回收和类的卸载
+ jdk8开始移除方法区的永久代、增加元空间，类的数据存储到元空间中，静态变量和常量池存储到堆中
+ 常量池：Class文件中的常量池（字面量和符号引用）会被存储到运行时常量池、也可以动态生成常量如String的intern()

#### 直接内存

在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。

# 垃圾回收

### 对象的创建方式

#### 碰撞指针

基于连续完整的内存，将空闲和一已用的内存分开，指向分解的指针向空闲移动对象大小

#### 空闲列表

虚拟机维护了一个内存块可用的列表，找到一个足够大的内存，分配对象

### 如何判断一个对象是否要回收

#### 引用计数法

对象引用一次，次数加1，失去引用计数减1。计数器为0则是需要回收的对象

无法解决相互应用的问题。

#### 根可达分析法

从GCROOTS出发，找到引用链，在链上的是不需要回收的

GCROOTS对象：

+ 虚拟机栈（栈帧本地变量表）中引用的对象
+ 方法区中的静态属性引用的对象
+ 方法去中的常量引用的对象
+ 本地方法栈中的JNI（一般说的Native方法）的引用的对象

###  JAVA中的引用

判断对象是否被回收与引用有关

#### 强引用

+ 任何时候都不会被回收，因为他是可达的，通过new创建的对象都是强引用

#### 软引用

+ 内存不足的时候对只有软引用的对象进行回收，可以通过SoftReference创建软引用，软引用常用来做高速缓存的缓冲区，需要使用引用队列

```
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
-Xms8m -Xmx8m -XX:+PrintGCDetails 限定堆的大小，
```

#### 弱引用

+ 用来描述非必须的对象，下一次gc到来的时候就被回收

#### 虚引用

+  虚引用对对象的生存时间不会构成影响，也无法通过虚引用找到对象的实例

### 对象不可达立即回收？

+ 不可达的对象经过两次标记后才被回收，判断对象不可达后进行第一次标记，虚拟机判断对象需要执行finalize()的对象放入到队列中，在队列中对不可达对象再次标记，进行回收。

### 方法区的回收

+ 主要回收废弃常量和无用的类
+ 判断一个类对象是否无用：
    + 该类的所有实例已经被回收
    + 加载该类的ClassLoader已经被回收
    + 该类对应的java.lang.Class独享没有在任何地方被引用，无法在任何地方使用反射访问该类的方法

### 垃圾收集算法

#### 标记清除

+ 对需要回收的对象进行标记，然后清理
+ 标记和清理的时间都很长。产生内存碎片

#### 复制算法

+ 将内存分成两份，一份用完了将存活对象赋值到另一份上
+ 内存利用率低
+ 用于回收年轻代，一份Eden和两份Survivor区 8：1：1，每次Eden区满了将Eden和Survivor取存活的对象复制到另外一个Survivor区

#### 标记整理

+ 让所有的存活的对象向一端移动，清理掉边界外的内存

#### 分代收集

+ 根据对象的存活周期划分内存，划分为年轻代和老年代，分代不同使用不同的收集算法
+ 年轻代存活的对象少，使用复制算法，老年代存活对象多，没有空余的空间进行分配担保，需使用标记清除或者标记整理

### 垃圾收集器

#### CMS

+ 初始标记：只标记和GCROOTS直接相连的对象，速度很快
+ 并发标记：正是根据引用链进行标记
+ 重新标记：修改因为用户程序和并发标记同时进行的对标记产生的影响
+ 并发清除：和用户程序一起运行，清除对象
+ 优点：低延迟、回收时虚拟机停顿时间短
+ 缺点：
  + 对CPU敏感，当CPU核心数量少的时候，用户程序会感受到变慢、吞吐量变低。可进行优化，在并发标记和并发清理的时候让GC和用户线程交替运行。
  + 无法处理浮动垃圾，用户线程在并发标记后产生的新垃圾无法从新标记。
  + 基于标记清理，产生内存碎片

#### G1

+ 基于标记整理算法
+ 可以精确的控制停顿， 可以控制在M毫秒内垃圾收集的时间不得高于N毫秒
+ 将垃圾收集堆分为多个独立的区域，优先收集垃圾最多的区域



# 类文件结构

## Class文件格式

+ 八个字节为基础的二进制流

### 无符号数

+ 以u1、u2、u4、u8来代表 1个、2个、4个、8个字节的无符号数，无符号数可以描述数字，索引引用，数量值，或者按照utf8编码构成的字符串的值

#### 魔数

+ 类文件前四个字节为魔数，用于验证类文件是不是合法的

#### 版本号

+ 魔数后四个字节为版本号，（次主版本号）

#### 常量池

+ 紧接着版本号后面是常量池，在常量池中最开始有一个u2类型的数，代表常量池中的常量数量
+ 常量池中的两大常量
  + 字面量：文本字符串或者代码里的final常量值
  + 符号引用：类和接口的全类名，字段的名称、方法的名称

#### 访问标识

+ 记录类的特性，如是接口还是类，是否被声明final等

#### 类索引、父类索引、接口索引的集合

+ 类索引用于确定这个类的全限定名
+ 父类索引用于确定这个父类的全限定名
+ 接口索引集合用于确定实现了的接口全限定名

#### 字段表集合

+ 描述了接口或者类中声明的变量

#### 方法表集合

#### 属性表集合



# 类加载机制

### 类加载的时机

+ 遇到new、getstatic、putstatic或invokstatic这四条字节码指令时，对应着使用new实例化一个对象、读取或者设置一个类的静态字段（被final修饰除外，它已经在编译器将结果放入到常量池）。
+ 使用反射调用类类
+ 初始化一个类发现其父类没有别初始化，先触发其父类
+ 虚拟机启动，虚拟机先加载主类

### 类加载过程

#### 加载

+ 通过类的全限定名获取二进制字节流
+ 将class文件静态数据结构转化为方法区中的运行时数据结构
+ 在堆中生成一个Class对象作为方法区的数据访问入口

#### 验证

##### 文件格式验证

+ 魔数、版本号、常量池中常量类型是不是合法

##### 元数据验证

+ 对元数据信息进行语义验证，例如是否继承了final类，重载方法是不是合法，是不是实现了抽象类中的所有方法

##### 字节码验证

+ 对类的方法体进行校验分析，保证运行时的安全性

##### 符号引用验证

+ 对符号引用的有效性进行验证，例如符号引用是否能找到对应的类

#### 准备

+ 为类变量附初始值，每种类型都有一个初始值。

#### 解析

+ 将常量池中的符号引用转化为直接引用
+ 将第一次解析的结果进行缓存，在运行时常量池记录缓存的直接引用，把标识改成已解析，可以解决重复解析的问题

#### 初始化

+ 根据代码的主观计划初始化变量和资源
+ clinit()方法是由编译器收集了所有类变量和静态语句块

#### 使用

#### 卸载

### 双亲委派机制

+ 启动类加载器：将java_home下的lib包中或者-Xbootclasspath参数指定的路径下的类加载
+ 扩展类加载器：将java_home\lib\ext目录中的或者被java.ext.dirs系统变量指定的路径所有类库
+ 应用类加载器（系统类加载器）：负责加载用户类路径上锁制定的类库，一般情况下程序默认的类加载器。
+ 除了顶层的启动类加再起，剩下的都有自己的父类加载器。每当接收到需要加载类的请求时，尝试让父类去加载。
+ 双亲委派机制的好处：让类随着加载器带有了优先级的层次关系，

# 虚拟机的优化

### 线程安全与锁的优化

#### 自旋锁与自适应锁

+ 锁竞争导致的阻塞和线程的唤醒会导致用户态和核心态的状态转化，减少转化的性能消耗

+ 当获取锁不成功的时候进入一个忙等待的过程，自旋一段时间
+ 自适应自旋：
  + 一直自旋会一直占用CPU的资源，自适应自旋会根据当前锁对象上一次的自旋时间和锁状态来决定是否自旋或自旋时间
  + jdk1.6引入了自适应的自旋锁，根据前一次的同一个上锁的自旋时间及锁的拥有者的状态来决定。在同一个锁对象上，如果自选等待刚刚通过，并且持有锁的线程正在运行中，那么虚拟机会认为自旋很有可能再次成功，会增加自选等待的时间，反之，对于某个锁自旋很少成功过，那么虚拟就就可以省略掉自旋过程。

#### 锁清除

+ 依靠逃逸分析，判断代码块中分配在堆上的对象都不会逃逸出去被其他线程访问到，锁就被消除

#### 锁粗化

+ 虚拟机对代码进行优化，将对同一个锁对象反复加锁和解锁和并成一个同步过程

#### 轻量级锁

+ 对象头
  + Mark Word：存储对象自身运行时数据，如Hash码、GC分带年龄、锁标志位等
  + 指向方法区类型数据得指针
+ 锁标志位的状态：
  + 01：未加锁
  + 00：轻量级锁
  + 10：重量级锁
  + 11：GC标记
  + 01：可偏向
+ 实现步骤：
  + 第一次获取锁，如果对象是未锁定状态的话，在栈帧上建立一个Lock Record的锁空间，存储当前Mark Work 的copy
  + 使用CAS将Mark Word 修改成Lock Record的引用，并将标志位转化为轻量锁
  + 如果失败了，首先检查当前锁对象的Mark Word是不是已经指向当前线程的栈帧，表示当前线程已经拥有了该独对象的锁。如果锁被别的线程拥有了，表示拥有线程竞争，需要进行锁的升级
  + 优点：使用CAS避免了互斥量的开销 
  + 确定：线程竞争激烈，非但没有节省互斥量的开销，反而额外增加了CAS的操作

#### 偏向锁

+ 实现同轻量级锁，从第二次起，如果锁没有别其他线程获取，那么就无须再进行同步