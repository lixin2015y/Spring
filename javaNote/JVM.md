## 内存模型
### 程序计数器
### 虚拟机栈
+ 存放了编译器就可以知道的基本类型、对象引用、returnAddress类型
+ 64位的log和double类型占用两个局部变量空间，其余的占一个。进入一个方法，在栈帧中需要分配的内存空间就可以确定了，
，所以在方法运行时是不会改变栈帧的大小了。
+ 虚拟机栈抛出的异常，StackOverFlowError和OutOfMemoryError有什么区别？ 
前者是虚拟机栈深度大于虚拟机允许的深度（深度可以动态扩展），后者是无法请求到足够的内存分配虚拟机栈内存
### java堆
+ 在堆中没有内存完成实例分配会抛出OutOfMemoryError
### 方法区
+ 线程共享，存储被虚拟机加载的类信息、常量、静态变量、即时编译的代码。
+ 使用永久代实现方法区跟家容易导致内存溢出，永久代设置参数-XX:MaxPermSize
#### 运行时常量池
+ 属于方法区的一部分。用于存放编译器生成的带各种字面量和符号引用、直接引用。类加载后这部分内容就被放到常量池。
+ 关于符号引用和直接引用： ========================此处待解决
+ 常量池无法申请到内存空间时会出现OutOfMemoryError。
+ String类的intern()方法可以在运行期间将新的常量放入池中。
+ 
### 直接内存
+ 一种基于通道与缓冲区的I/O方式，可以使用native方法在堆外分配内存。可以通过一个促进处在java堆中的
DirectByteBuffer 对象作为这块内存的引用进行操作。避免了在java堆和native堆中来回复制数据
+ 忽视直接内存的空间限制，各个内存区域的总和大于物理内存限制还是会出现
## 对象是如何创建
+  JVM内存分配的方式：
    + 指针碰撞：已用和空闲内存放到两边，中间的指针向空闲内存移动对象需要内存的大小。
针对于连续的堆内存 
    + 空闲列表： 虚拟机维护一个记录了那块内存块可用的列表。分配时选择找到一个足够大的内幕才能进行分配。
---深入理解java虚拟机p67
