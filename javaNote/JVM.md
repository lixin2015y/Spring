## 内存模型
### 程序计数器
### 虚拟机栈
+ 存放了编译器就可以知道的基本类型、对象引用、returnAddress类型
+ 64位的log和double类型占用两个局部变量空间，其余的占一个。进入一个方法，在栈帧中需要分配的内存空间就可以确定了，
，所以在方法运行时是不会改变栈帧的大小了。
+ 虚拟机栈抛出的异常，StackOverFlowError和OutOfMemoryError有什么区别？ 
前者是虚拟机栈深度大于虚拟机允许的深度（深度可以动态扩展），后者是无法请求到足够的内存分配虚拟机栈内存
### java堆
+ 在堆中没有内存完成实例分配会抛出OutOfMemoryError
### 方法区
+ 线程共享，存储被虚拟机加载的类信息、常量、静态变量、即时编译的代码。
+ 使用永久代实现方法区跟家容易导致内存溢出，永久代设置参数-XX:MaxPermSize
#### 运行时常量池
+ 属于方法区的一部分。用于存放编译器生成的带各种字面量和符号引用、直接引用。类加载后这部分内容就被放到常量池。
+ 关于符号引用和直接引用： ========================此处待解决
+ 常量池无法申请到内存空间时会出现OutOfMemoryError。
+ String类的intern()方法可以在运行期间将新的常量放入池中。
+ 
### 直接内存
+ 一种基于通道与缓冲区的I/O方式，可以使用native方法在堆外分配内存。可以通过一个促进处在java堆中的
DirectByteBuffer 对象作为这块内存的引用进行操作。避免了在java堆和native堆中来回复制数据
+ 忽视直接内存的空间限制，各个内存区域的总和大于物理内存限制还是会出现
## 对象是如何创建
+  JVM内存分配的方式：
    + 指针碰撞：已用和空闲内存放到两边，中间的指针向空闲内存移动对象需要内存的大小。
针对于连续的堆内存 
    + 空闲列表： 虚拟机维护一个记录了那块内存块可用的列表。分配时选择找到一个足够大的内幕才能进行分配。
## 访问对象的方式
### 使用句柄
+ 如果使用句柄地址的话，栈帧中的reference存储的就是对象的句柄地址，在堆中有一个句柄池，而句柄中包含对象实例
数据和类型数据各自的地址。
+ 优点：在对象被移动（垃圾回收时非常普遍）只需要改变句柄中的实例数据指针就可以，不需要修改reference
### 直接引用
+ 如果使用直接引用，reference存储的就是对象实例(其中包含到对象类型数据的指针)的地址，
+ 直接指针访问速度快，节省了一次指针定位的时间开销，这个是HotSpot的默认的对象访问方式。

## 内存溢出
### 堆内存溢出
+ 首先使用内存分析工具确定内存中的对象是否是必要的，分清是内存泄漏还是内存溢出
+ 如果是内存泄漏，可以通过工具查看GC Roots的引用链，找到对象是通过什么方式和引用链相连
导致不能对其进行回收。
+ 如果是内存溢出（也就是内存中的对象是必要的），需要检查虚拟的对参数 -Xms 和-Xms
在代码上减少程序运行期间的内存消耗。
### 虚拟机栈和本地方法栈溢出
+ -Xoss 参数设置本地方法栈内存（虽然存在但是无效）  -Xss设置虚拟机栈内存。
### 运行时常量池溢出
+ 向常量池中添加内容，最简单的做法就是使用String.intern()这个native方法，如果池中已经存在次字符串，则直接返回
该字符串的引用，否则将将次字符串你添加到常量池中，并返回String对象的引用。

### 方法区溢出

+ 方法区用于存放Class的相关信息，例如类名、访问修饰符、常量池、字段描述、方法描述等，生成过多的动态类加载入内存

  可以使方法区内存溢出

### 本机直接内存溢出

+ DirectMemory容量可以通过-XX:MaxDirctmemorySize指定，如果不指定默认与java堆大小一样。



## 垃圾收集器与内存分配策略

### 引用计数法

+ 

### 根搜索算法

### 再谈引用

