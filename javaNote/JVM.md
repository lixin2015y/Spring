## 内存模型
### 程序计数器
### 虚拟机栈
+ 存放了编译器就可以知道的基本类型、对象引用、returnAddress类型
+ 64位的log和double类型占用两个局部变量空间，其余的占一个。进入一个方法，在栈帧中需要分配的内存空间就可以确定了，
，所以在方法运行时是不会改变栈帧的大小了。
+ 虚拟机栈抛出的异常，StackOverFlowError和OutOfMemoryError有什么区别？ 
前者是虚拟机栈深度大于虚拟机允许的深度（深度可以动态扩展），后者是无法请求到足够的内存分配虚拟机栈内存
### java堆
+ 在堆中没有内存完成实例分配会抛出OutOfMemoryError
### 方法区
+ 线程共享，存储被虚拟机加载的类信息、常量、静态变量、即时编译的代码。
+ 使用永久代实现方法区跟家容易导致内存溢出，永久代设置参数-XX:MaxPermSize
#### 运行时常量池
+ 属于方法区的一部分。用于存放编译器生成的带各种字面量和符号引用、直接引用。类加载后这部分内容就被放到常量池。
+ 关于符号引用和直接引用： ========================此处待解决
+ 常量池无法申请到内存空间时会出现OutOfMemoryError。
+ String类的intern()方法可以在运行期间将新的常量放入池中。
+ 
### 直接内存
+ 一种基于通道与缓冲区的I/O方式，可以使用native方法在堆外分配内存。可以通过一个促进处在java堆中的
DirectByteBuffer 对象作为这块内存的引用进行操作。避免了在java堆和native堆中来回复制数据
+ 忽视直接内存的空间限制，各个内存区域的总和大于物理内存限制还是会出现
## 对象是如何创建
+  JVM内存分配的方式：
    + 指针碰撞：已用和空闲内存放到两边，中间的指针向空闲内存移动对象需要内存的大小。
针对于连续的堆内存 
    + 空闲列表： 虚拟机维护一个记录了那块内存块可用的列表。分配时选择找到一个足够大的内幕才能进行分配。
## 访问对象的方式
### 使用句柄
+ 如果使用句柄地址的话，栈帧中的reference存储的就是对象的句柄地址，在堆中有一个句柄池，而句柄中包含对象实例
数据和类型数据各自的地址。
+ 优点：在对象被移动（垃圾回收时非常普遍）只需要改变句柄中的实例数据指针就可以，不需要修改reference
### 直接引用
+ 如果使用直接引用，reference存储的就是对象实例(其中包含到对象类型数据的指针)的地址，
+ 直接指针访问速度快，节省了一次指针定位的时间开销，这个是HotSpot的默认的对象访问方式。

## 内存溢出
### 堆内存溢出
+ 首先使用内存分析工具确定内存中的对象是否是必要的，分清是内存泄漏还是内存溢出
+ 如果是内存泄漏，可以通过工具查看GC Roots的引用链，找到对象是通过什么方式和引用链相连
导致不能对其进行回收。
+ 如果是内存溢出（也就是内存中的对象是必要的），需要检查虚拟的对参数 -Xms 和-Xms
在代码上减少程序运行期间的内存消耗。
### 虚拟机栈和本地方法栈溢出
+ -Xoss 参数设置本地方法栈内存（虽然存在但是无效）  -Xss设置虚拟机栈内存。
### 运行时常量池溢出
+ 向常量池中添加内容，最简单的做法就是使用String.intern()这个native方法，如果池中已经存在次字符串，则直接返回
该字符串的引用，否则将将次字符串你添加到常量池中，并返回String对象的引用。

### 方法区溢出

+ 方法区用于存放Class的相关信息，例如类名、访问修饰符、常量池、字段描述、方法描述等，生成过多的动态类加载入内存

  可以使方法区内存溢出

### 本机直接内存溢出

+ DirectMemory容量可以通过-XX:MaxDirctmemorySize指定，如果不指定默认与java堆大小一样。



## 垃圾收集器与内存分配策略
### 引用计数法
+ 给对象中加一个应用计数器，每个地方引用过它时，计数器值+1，引用失效，计数器值-1，计数器为0的兑现就是不再被使用的。
，java中没有使用引用计数法来管理内存，组要的原因是因为他很那解决对象之间的相互循环引用问题。
### 根搜索算法
+ 从GCRoot对象作为七点，搜索所走得过的引用链， 如果一个对象到GCRoots没有任何引用链相连
（从GCRoots到这个对象是不可达的），证明该对象是不可用的。
+ GCRoots对象包括：
  + 虚拟机栈（栈帧本地变量表）中引用的对象
  + 方法区中的静态属性引用的对象
  + 方法去中的常量引用的对象
  + 本地方法栈中的JNI（一般说的Native方法）的引用的对象

### 再谈引用
+ 引用定义：如果reference类型中的数据存储的数值代表另外一块内存的其实地址，则称这一块内存代表着一个引用
+ 强引用：强引用在任何时候都不会被回收，因为他是可达的
+ 软引用：在内存不足时被回收，可以使用SoftReference来实现软引用，可以使用引用队列实现SoftReference的销毁

```java
    /**
     * 测试软引用
     * -Xms8m -Xmx8m -XX:+PrintGCDetails 限定堆的大小，
     */
    @Test
    public void test() throws InterruptedException {

        Person person = new Person("张三");
//        Person person2 = new Person("张三"); 我们设定的内存同时创建两个person就会报oom
        SoftReference<Person> softReference = new SoftReference<>(person);

        person = null;//去掉强引用，new Person("张三")的这个对象就只有软引用了

        //在此处创建一个对象，使得内存不足需要回收软引用 如果不创建这个对象，软引用是不会被回收的，线面还是能得到李四对象。
        Person anotherPerson = new Person("李四");

        Thread.sleep(1000);

        System.err.println("软引用的对象 ------->" + softReference.get());

    }
```
+ 弱引用：用来描述非必须的对象，下一次gc到来的时候就被回收
+ 虚引用：如果一个对象仅仅存在虚引用，那么和没有任何引用是一样的，
+ 使用最多的是软引用，它可以加速对垃圾内存的回收速度，可以维护系统的安全，防止OOM
#### 回收方法区
+ 回收方法区的常量比较简单，只需要判断是不是有其他地方引用他就可以了
+ 判断方法区中的类是否是无用的类：
  + 该类的所有实例已经被回收
  + 加载该类的ClassLoader已经被回收
  + 该类对应的java.lang.Class独享没有在任何地方被引用，无法在任何地方使用反射访问该类的方法
  
### 垃圾回收算法

#### 标记-清除算法

+ 首先标记出所有需要清除的对象，在标记完成后统一回收掉被标记的对象
+ 缺点：标记和清除的效率都很低，清除后会出现大量不连续的内存碎片

#### 赋值算法

+ 将内存划分为相等的两份，然后实现，每次只是用其中一块，这块内存块使用完后，将存活的对象复制到另外一块上面，然后将已使用过的一次清理掉
+ 优点：无需考虑内存碎片问题，运行高效
+ 确定：使用内存只占了原来的一半

#### 标记整理

+ 标记后让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

#### 分带收集

+ 分带收集：根据对象的存活周期的不同将内存分为新生代和老年代。根据各个分区的特点，
选择最适当的收集算法。年轻代使用复制算法，老年代使用标记清除或者标记整理算法。

### 垃圾收集器
#### CMS
+ 追求最短的停顿时间，重视服务的响应速度，基于标记清除算法，常用于基于BS架构的项目

+ 步骤：初始标记、并发标记、重新标记、并发清除

+ 初始标记：标记直接与GCRoots直接相连的对象，速度很快

+ 并发标记：对GCRoots进行tracing

+ 重新标记：修正并发标记期间，因用户程序继续运行导致的标记产生变动的那一部分对象的标记，所需时间大于初始标记，远小于并发标记

+ 并发清除：和用户线程一起对标记的对象进行清除

+ 缺点：1、对CPU资源较敏感。CMS的回收线程数，默认为（CPU核心数+3）/ 4，当CPU在四个以上是，CMS是不会占用CPU的太多资源的，当CPU不足四个时，CMS收集线程就会占用过多的资源

  为了解决这种问题，虚拟机剔除ICMS增量式并发收集器，让GC线程和用户线程交替运行， 减少GC独占CPU资源的时间。2、无法处理浮动垃圾（标记后用户线程产生的垃圾）， 3、基于标记清理，产生大量的内存碎片。内存碎片化将会给大对象分配空间带来很大的麻烦。虚拟机虽然提供一个碎片整理的过程，但是在真理过程中是无法并发的，导致系统反应变慢。 

#### G1

+ 1、基于标记-整理算法，不会产生空间碎片 2、能够让使用者明确的指定在一个时间长度为M毫秒的时间片内，消耗在垃圾收集的时间不超过N秒，3、他将堆内存分成多个大小独立的区域，根据各个区域垃圾堆积的程度，在后台维护一个优先列表。每次根据允许的收集时间优先回收最多的区域。







### 类文件的结构

#### Class文件的格式

+ 八个字节的为基础的二进制流
+ 如果遇到需要大于八字节的会按照高位在前的方式分配成若干个八为字节
+ 数据类型：无符号数和表

##### 无符号数

+ 以u1、u2、u4、u8来代表 1个、2个、4个、8个字节的无符号数，无符号数可以描述数字，索引引用，数量值，或者按照utf8编码构成的字符串的值

##### 表

+ 是由多个无符号数或其他表组成的复合型数据结构，真个class文件就是一张表。



##### 魔术和Class文件的版本

+ 前四个字节是class文件的魔数用于确定这个文件是否能被虚拟机加载。
+ 魔数后四个字节第5、6是次版本号，第7、8是主版本号

##### 常量池

+ 紧接着魔数和版本号之后就是常量池的入口，
+ 常量池的入口有个u2类型的数代表常量池的容量。
+ 如果常量池的容量为22则只有21个常量，。（0索引被空出来表示不引用任何常量池项目）
+ 常量池中的两大常量，字面量和符号引用。
+ 字面量：接近java虚拟机的常量，如文本字符串或者都被final生命的常量。
+ 符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符
+ ![image-20200603073751436](C:\Users\lixin\AppData\Roaming\Typora\typora-user-images\image-20200603073751436.png)

##### 访问标志

+ 常量池结束后端两个字节是访问标志
+ 