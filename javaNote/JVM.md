## 内存模型
### 程序计数器
### 虚拟机栈
+ 存放了编译器就可以知道的基本类型、对象引用、returnAddress类型
+ 64位的log和double类型占用两个局部变量空间，其余的占一个。进入一个方法，在栈帧中需要分配的内存空间就可以确定了，
，所以在方法运行时是不会改变栈帧的大小了。
+ 虚拟机栈抛出的异常，StackOverFlowError和OutOfMemoryError有什么区别？ 
前者是虚拟机栈深度大于虚拟机允许的深度（深度可以动态扩展），后者是无法请求到足够的内存分配虚拟机栈内存
### java堆
+ 在堆中没有内存完成实例分配会抛出OutOfMemoryError
### 方法区
+ 线程共享，存储被虚拟机加载的类信息、常量、静态变量、即时编译的代码。
+ 使用永久代实现方法区跟家容易导致内存溢出，永久代设置参数-XX:MaxPermSize
#### 运行时常量池
+ 属于方法区的一部分。用于存放编译器生成的带各种字面量和符号引用、直接引用。类加载后这部分内容就被放到常量池。
+ 关于符号引用和直接引用： ========================此处待解决
+ 常量池无法申请到内存空间时会出现OutOfMemoryError。
+ String类的intern()方法可以在运行期间将新的常量放入池中。
+ 
### 直接内存
+ 一种基于通道与缓冲区的I/O方式，可以使用native方法在堆外分配内存。可以通过一个促进处在java堆中的
DirectByteBuffer 对象作为这块内存的引用进行操作。避免了在java堆和native堆中来回复制数据
+ 忽视直接内存的空间限制，各个内存区域的总和大于物理内存限制还是会出现
## 对象是如何创建
+  JVM内存分配的方式：
    + 指针碰撞：已用和空闲内存放到两边，中间的指针向空闲内存移动对象需要内存的大小。
针对于连续的堆内存 
    + 空闲列表： 虚拟机维护一个记录了那块内存块可用的列表。分配时选择找到一个足够大的内幕才能进行分配。
## 访问对象的方式
### 使用句柄
+ 如果使用句柄地址的话，栈帧中的reference存储的就是对象的句柄地址，在堆中有一个句柄池，而句柄中包含对象实例
数据和类型数据各自的地址。
+ 优点：在对象被移动（垃圾回收时非常普遍）只需要改变句柄中的实例数据指针就可以，不需要修改reference
### 直接引用
+ 如果使用直接引用，reference存储的就是对象实例(其中包含到对象类型数据的指针)的地址，
+ 直接指针访问速度快，节省了一次指针定位的时间开销，这个是HotSpot的默认的对象访问方式。

## 内存溢出
### 堆内存溢出
+ 首先使用内存分析工具确定内存中的对象是否是必要的，分清是内存泄漏还是内存溢出
+ 如果是内存泄漏，可以通过工具查看GC Roots的引用链，找到对象是通过什么方式和引用链相连
导致不能对其进行回收。
+ 如果是内存溢出（也就是内存中的对象是必要的），需要检查虚拟的对参数 -Xms 和-Xms
在代码上减少程序运行期间的内存消耗。
### 虚拟机栈和本地方法栈溢出
+ -Xoss 参数设置本地方法栈内存（虽然存在但是无效）  -Xss设置虚拟机栈内存。
### 运行时常量池溢出
+ 向常量池中添加内容，最简单的做法就是使用String.intern()这个native方法，如果池中已经存在次字符串，则直接返回
该字符串的引用，否则将将次字符串你添加到常量池中，并返回String对象的引用。

### 方法区溢出

+ 方法区用于存放Class的相关信息，例如类名、访问修饰符、常量池、字段描述、方法描述等，生成过多的动态类加载入内存

  可以使方法区内存溢出

### 本机直接内存溢出

+ DirectMemory容量可以通过-XX:MaxDirctmemorySize指定，如果不指定默认与java堆大小一样。



## 垃圾收集器与内存分配策略
### 引用计数法
+ 给对象中加一个应用计数器，每个地方引用过它时，计数器值+1，引用失效，计数器值-1，计数器为0的兑现就是不再被使用的。
，java中没有使用引用计数法来管理内存，组要的原因是因为他很那解决对象之间的相互循环引用问题。
### 根搜索算法
+ 从GCRoot对象作为七点，搜索所走得过的引用链， 如果一个对象到GCRoots没有任何引用链相连
（从GCRoots到这个对象是不可达的），证明该对象是不可用的。
+ GCRoots对象包括：
  + 虚拟机栈（栈帧本地变量表）中引用的对象
  + 方法区中的静态属性引用的对象
  + 方法去中的常量引用的对象
  + 本地方法栈中的JNI（一般说的Native方法）的引用的对象

### 再谈引用
+ 引用定义：如果reference类型中的数据存储的数值代表另外一块内存的其实地址，则称这一块内存代表着一个引用
+ 强引用：强引用在任何时候都不会被回收，因为他是可达的
+ 软引用：在内存不足时被回收，可以使用SoftReference来实现软引用，可以使用引用队列实现SoftReference的销毁

```java
    /**
     * 测试软引用
     * -Xms8m -Xmx8m -XX:+PrintGCDetails 限定堆的大小，
     */
    @Test
    public void test() throws InterruptedException {

        Person person = new Person("张三");
//        Person person2 = new Person("张三"); 我们设定的内存同时创建两个person就会报oom
        SoftReference<Person> softReference = new SoftReference<>(person);

        person = null;//去掉强引用，new Person("张三")的这个对象就只有软引用了

        //在此处创建一个对象，使得内存不足需要回收软引用 如果不创建这个对象，软引用是不会被回收的，线面还是能得到李四对象。
        Person anotherPerson = new Person("李四");

        Thread.sleep(1000);

        System.err.println("软引用的对象 ------->" + softReference.get());

    }
```
+ 弱引用：用来描述非必须的对象，下一次gc到来的时候就被回收
+ 虚引用：如果一个对象仅仅存在虚引用，那么和没有任何引用是一样的，
+ 使用最多的是软引用，它可以加速对垃圾内存的回收速度，可以维护系统的安全，防止OOM
#### 回收方法区
+ 回收方法区的常量比较简单，只需要判断是不是有其他地方引用他就可以了
+ 判断方法区中的类是否是无用的类：
  + 该类的所有实例已经被回收
  + 加载该类的ClassLoader已经被回收
  + 该类对应的java.lang.Class独享没有在任何地方被引用，无法在任何地方使用反射访问该类的方法
  
### 垃圾回收算法

#### 标记-清除算法

+ 首先标记出所有需要清除的对象，在标记完成后统一回收掉被标记的对象
+ 缺点：标记和清除的效率都很低，清除后会出现大量不连续的内存碎片

#### 赋值算法

+ 将内存划分为相等的两份，然后实现，每次只是用其中一块，这块内存块使用完后，将存活的对象复制到另外一块上面，然后将已使用过的一次清理掉
+ 优点：无需考虑内存碎片问题，运行高效
+ 确定：使用内存只占了原来的一半

#### 标记整理

+ 标记后让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

#### 分带收集

+ 

